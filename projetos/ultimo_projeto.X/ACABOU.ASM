
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     DESCRIÇÃO DO ARQUIVO                        *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 16F628A                                     *
;*                                                                 *
;*                                                                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

#INCLUDE <p16f628a.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 16F628A

;---CONFIGURAÇAO DOS FUSE BITS---
;-CRISTAL OSCILADOR EXTERNO 4MHZ
;-WDT DESABILITADO
;-POWER UP TIMER HABILITADO
;-MASTER CLEAR HABILITADO
;-BROWN OUT DESABILITADO
;-SEM PROGRAMAÇAO EM BAIXA TENSAO
;-SEM PROTEÇAO DA MEMORIA DE DADOS
;-SEM PROTEÇAO DE CODIGO

;---FUSE BITS---
    __CONFIG _XT_OSC & _WDT_ON & _PWRTE_ON & _MCLRE_ON &_BOREN_OFF & _LVP_OFF & _CPD_OFF & _CP_OFF

;---PAGINAÇAO DE MEMORIA---
#DEFINE	BANK0	BCF STATUS,RP0		;SELECIONA O BANCO 0 DE MEMORIA
#DEFINE	BANK1	BSF STATUS,RP0		;SELECIONA O BANCO 1 DE MEMORIA

;---VARIAVEIS---
    CBLOCK	0X20			;ENDEREÇO INICIAL DA MEMORIA DO USUARIO
	
    TEMPERATURE_I			;PARTE INTEGRAL DA TEMPERATURA
    TEMPERATURE_D			;PARTE DECIMAL DA TEMPERATURA
    HUMIDITY_I				;PARTE INTEGRAL DA HUMIDADE
    HUMIDITY_D				;PARTE DECIMAL DA HUMIDADE
    CHECKSUM				;VALOR DA SOMA DOS REGISTADORES ANTERIORES
    COUNT				;A VARIÁVEL COUNT IRA AUXILIAR NA CONTAGEM DA QUANTIDADE DE BITS REREBIDOS
    INDEX_REG				;IRÁ INDEXAR QUAL REGISTRADOR ESTÁ SENDO TRABALHO. (H_I = 0, H_D = 1, T_I = 2, T_D = 3, CHECKSUM = 4, END = 5)
    TEMP_TMR2
    TEMP
    
    TEMPERATURE_DEZ			;PARTE DA DEZENA DA TEMPERATURA
    TEMPERATURE_UNI			;PARTE DA UNIDADE DA TEMPERATURA
    HUMIDITY_DEZ			;PARTE DA DEZENA DA HUMIDADE
    HUMIDITY_UNI			;PARTE DA UNIDADE DA HUMINDADE
    
    DISPLAY				;USADA PARA ESCREVER NO DISPLAY
    
    
    ENDC				;FIM DO BLOCO DE MEMORIA
    
;---VETOR DE RESET---
    ORG		H'0000'			;ORIGEM NO ENDERECO 00H DE MEMORIA
    GOTO	INICIO			;DESVIA PARA ROTINA INICIO

;---VETOR DE INTERRUPCAO--
    ORG		H'0004'			;AS INTERRUPCOES APONTAM PARA 04H
    RETFIE				;RETORNA DA INTERRUPCAO

;---ROTINAS---
    
ATT_COUNT_AND_INDEX
    CLRF    COUNT
    RLF	    INDEX_REG
    RETURN

;ROTINAS DE TEMPO
WAIT_40US
    BANK0
    MOVLW   B'00000100'		
    MOVWF   T2CON			;COLOCA O TMR2 EM PSA DE 1:1
    BCF	    PIR1, 1			;LIMPA POR SEGURNÇA A FLAG DE ESTOURO DO TMR2
    MOVLW   .220
    MOVWF   TMR2			;COLOCA O TMR0 PARA 215 E ELE CONTARA DURANTE UM POUCO MAIS DE 40US, QUE É O TEMPO ESTIPULADO
LOOP_40US				;LOOP DE ESPERA DO TEMPO
    BTFSS   PIR1, 1
    GOTO    LOOP_40US
    BCF	    PIR1, 1
    RETURN 
    
WAIT_50US
    BANK0
    MOVLW   B'00000100'		
    MOVWF   T2CON			;COLOCA O TMR2 EM PSA DE 1:1
    BCF	    PIR1, 1			;LIMPA POR SEGURNÇA A FLAG DE ESTOURO DO TMR2
    MOVLW   .209
    MOVWF   TMR2			;COLOCA O TMR0 PARA 205 E ELE CONTARA DURANTE UM POUCO MAIS DE 160US, QUE É O TEMPO ESTIPULADO
LOOP_50US				;LOOP DE ESPERA DO TEMPO
    BTFSS   PIR1, 1
    GOTO    LOOP_50US
    BCF	    PIR1, 1
    RETURN     
             
WAIT_160US
    BANK0
    MOVLW   B'00000100'		
    MOVWF   T2CON			;COLOCA O TMR2 EM PSA DE 1:1
    BCF	    PIR1, 1			;LIMPA POR SEGURNÇA A FLAG DE ESTOURO DO TMR2
    MOVLW   .101
    MOVWF   TMR2			;COLOCA O TMR0 PARA 95 E ELE CONTARA DURANTE UM POUCO MAIS DE 160US, QUE É O TEMPO ESTIPULADO
LOOP_160US				;LOOP DE ESPERA DO TEMPO
    BTFSS   PIR1, 1
    GOTO    LOOP_160US
    BCF	    PIR1, 1
    RETURN  
    
WAIT_1MS
    BANK0
    MOVLW   B'00000101'		
    MOVWF   T2CON			;COLOCA O TMR2 EM PSA DE 1:4
    BCF	    PIR1, 1			;LIMPA POR SEGURNÇA A FLAG DE ESTOURO DO TMR2
    MOVLW   .0
    MOVWF   TMR2			;COLOCA O TMR0 PARA 0 E ELE CONTARA DURANTE UM POUCO MAIS DE 1 MS, QUE É O TEMPO ESTIPULADO
LOOP_1MS				;LOOP DE ESPERA DO TEMPO
    BTFSS   PIR1, 1
    GOTO    LOOP_1MS
    BCF	    PIR1, 1
    RETURN    
    
WAIT_2MS
    CALL    WAIT_1MS			;CHAMA DUAS VEZES A ROTINA DE 1MS PARA CONTAR ATE 2MS
    CALL    WAIT_1MS
    RETURN
   
WAIT_4MS
    CALL    WAIT_2MS			;CHAMA DUAS VEZES A ROTINA DE 2MS PARA CONTAR ATE 4MS
    CALL    WAIT_2MS
    RETURN
    
WAIT_18MS
    CALL    WAIT_4MS			;CHAMA 4 VEZES 4MS E UMA VEZ A DE 2MS, SOMANDO 18MS
    CALL    WAIT_4MS
    CALL    WAIT_4MS
    CALL    WAIT_4MS
    CALL    WAIT_2MS
    RETURN
;FIM DAS ROTINAS DE TEMPO

;ROTINAS DE ATUALIZAÇÃO DOS DADOS ENVIADOS DO SENSOR    
ATT_HUMIDITY_I
    MOVLW   .45				;VALOR CORRESPONDENTE A 45US, APROXIMADAMENTE.
    SUBWF   TEMP_TMR2, W		;FAZ O VALOR DO TMR2 - 45.
    BTFSS   STATUS, C			;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BCF	    HUMIDITY_I,0		;SE ENTRAR AQUI, O VALOR RECEBIDO É ZERO, ENTÃO ATRIBUI 0 AO REGISTRADOR
    MOVLW   .45				;A REPETIÇÃO DAS OPERAÇÕES A SEGUIR É PARA GARANTIR AS DUAS POSSIBILIDADES
    SUBWF   TEMP_TMR2, W					
    BTFSC   STATUS, C			;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BSF	    HUMIDITY_I,0		;CASO ENTRE AQUI, ENTÃO O VALOR RECEBIDO FOI UM. ENTRAR AQUI, QUER DIZER QUE A PRIMEIRA CONDIÇÃO DEU ERRADO.

    RLF	    HUMIDITY_I			;DESLOCA OS BITS PARA EQUERDA, PREPARANDO PARA O PRÓXIMO BIT.
    INCF    COUNT, F			;ADICIONA MAIS UM AO CONTADOR DE BITS PARA O REGISTRADOR
    ;OBS F - W FOR POSITIVO, STATUS C = 1	
    RETURN
    
ATT_HUMIDITY_D
    MOVLW   .45				;VALOR CORRESPONDENTE A 45US, APROXIMADAMENTE.
    SUBWF   TEMP_TMR2, W		;FAZ O VALOR DO TMR2 - 45.
    BTFSS   STATUS, C			;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BCF	    HUMIDITY_D,0		;SE ENTRAR AQUI, O VALOR RECEBIDO É ZERO, ENTÃO ATRIBUI 0 AO REGISTRADOR
    MOVLW   .45				;A REPETIÇÃO DAS OPERAÇÕES A SEGUIR É PARA GARANTIR AS DUAS POSSIBILIDADES
    SUBWF   TEMP_TMR2, W					
    BTFSC   STATUS, C			;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BSF	    HUMIDITY_D,0		;CASO ENTRE AQUI, ENTÃO O VALOR RECEBIDO FOI UM. ENTRAR AQUI, QUER DIZER QUE A PRIMEIRA CONDIÇÃO DEU ERRADO.

    RLF	    HUMIDITY_D			;DESLOCA OS BITS PARA EQUERDA, PREPARANDO PARA O PRÓXIMO BIT.
    INCF    COUNT, F			;ADICIONA MAIS UM AO CONTADOR DE BITS PARA O REGISTRADOR
    ;OBS F - W FOR POSITIVO, STATUS C = 1		
    RETURN
    
ATT_TEMPERATURE_I
    MOVLW   .45				;VALOR CORRESPONDENTE A 45US, APROXIMADAMENTE.
    SUBWF   TEMP_TMR2, W		;FAZ O VALOR DO TMR0 - 45.
    BTFSS   STATUS, C			;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BCF	    TEMPERATURE_I,0		;SE ENTRAR AQUI, O VALOR RECEBIDO É ZERO, ENTÃO ATRIBUI 0 AO REGISTRADOR
    MOVLW   .45				;A REPETIÇÃO DAS OPERAÇÕES A SEGUIR É PARA GARANTIR AS DUAS POSSIBILIDADES
    SUBWF   TEMP_TMR2, W					
    BTFSC   STATUS, C			;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BSF	    TEMPERATURE_I,0		;CASO ENTRE AQUI, ENTÃO O VALOR RECEBIDO FOI UM. ENTRAR AQUI, QUER DIZER QUE A PRIMEIRA CONDIÇÃO DEU ERRADO.

    RLF	    TEMPERATURE_I		;DESLOCA OS BITS PARA EQUERDA, PREPARANDO PARA O PRÓXIMO BIT.
    INCF    COUNT, F			;ADICIONA MAIS UM AO CONTADOR DE BITS PARA O REGISTRADOR
    ;OBS F - W FOR POSITIVO, STATUS C = 1	
    RETURN
    
ATT_TEMPERATURE_D
    MOVLW   .45				;VALOR CORRESPONDENTE A 45US, APROXIMADAMENTE.
    SUBWF   TEMP_TMR2, W		;FAZ O VALOR DO TMR0 - 45.
    BTFSS   STATUS, C			;;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BCF	    TEMPERATURE_D,0		;SE ENTRAR AQUI, O VALOR RECEBIDO É ZERO, ENTÃO ATRIBUI 0 AO REGISTRADOR
    MOVLW   .45				;A REPETIÇÃO DAS OPERAÇÕES A SEGUIR É PARA GARANTIR AS DUAS POSSIBILIDADES
    SUBWF   TEMP_TMR2, W					
    BTFSC   STATUS, C			;;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BSF	    TEMPERATURE_D,0		;CASO ENTRE AQUI, ENTÃO O VALOR RECEBIDO FOI UM. ENTRAR AQUI, QUER DIZER QUE A PRIMEIRA CONDIÇÃO DEU ERRADO.

    RLF	    TEMPERATURE_D		;DESLOCA OS BITS PARA EQUERDA, PREPARANDO PARA O PRÓXIMO BIT.
    INCF    COUNT, F			;ADICIONA MAIS UM AO CONTADOR DE BITS PARA O REGISTRADOR
    ;OBS F - W FOR POSITIVO, STATUS C = 1		
    RETURN
    
ATT_CHECKSUM
    MOVLW   .45				;VALOR CORRESPONDENTE A 45US, APROXIMADAMENTE.
    SUBWF   TEMP_TMR2, W		;FAZ O VALOR DO TMR0 - 45.
    BTFSS   STATUS, C			;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BCF	    CHECKSUM,0			;SE ENTRAR AQUI, O VALOR RECEBIDO É ZERO, ENTÃO ATRIBUI 0 AO REGISTRADOR
    MOVLW   .45				;A REPETIÇÃO DAS OPERAÇÕES A SEGUIR É PARA GARANTIR AS DUAS POSSIBILIDADES
    SUBWF   TEMP_TMR2, W					
    BTFSC   STATUS, C			;SE ESSE VALOR FOR POSITIVO, ENTÃO O VALOR RECEBDIDO É UM(0-70=70US). SE FOR NEGATIVO É ZERO(0-28=28US)
    BSF	    CHECKSUM,0			;CASO ENTRE AQUI, ENTÃO O VALOR RECEBIDO FOI UM. ENTRAR AQUI, QUER DIZER QUE A PRIMEIRA CONDIÇÃO DEU ERRADO.

    RLF	    CHECKSUM			;DESLOCA OS BITS PARA EQUERDA, PREPARANDO PARA O PRÓXIMO BIT.
    INCF    COUNT, F			;ADICIONA MAIS UM AO CONTADOR DE BITS PARA O REGISTRADOR
    
    BTFSC   COUNT,3			;CHECKSUM É O ULTIMO, PARA SABER SE ELE TERMINOU E PARA O LOOP DE LEITURA, VERIFICO SE JÁ CHEGOU AO FIM AQUI PARA MUDA O
    RLF	    INDEX_REG			;INDEX_REG PARA BIT5 = 1    

    
    ;OBS F - W FOR POSITIVO, STATUS C = 1		
    RETURN
;FIM DAS ROTINAS DE ATUALIZAÇÃO DOS DADOS ENVIADOS DO SENSOR    

;DEZENA_UNIDADE SEPARA A PARTE DA DEZENA DA UNIDADE DO TEMPERATURE E HUMIDITY
DEZENA_UNIDADE    
;LOOP PARA TEMPERATURA
LOOP_1	   	
    MOVLW   .10				;CARREGA O VALOR DEZ AO WORK, PARA SUBTRAIR DO FILE EM QUESTÃO
    SUBWF   TEMPERATURE_I, W		;F - W, SUBTRAI DE 10 EM DEZ
    BTFSS   STATUS,C			;SE O CARRY FOR A 1, ENTÃO EU INCREMETO A PARTE DA DEZENA, CASO SEJA 0, ENTÃO NÃO HÁ MAIS NADA NA DEZENA E SALVO O RESTO NA UNIDADE
    GOTO    RESTO_TEMPERATURE		;PULA PARA PARTE ONDE SALVA O RESTO
    INCF    TEMPERATURE_DEZ		;INCREMENTA A PARTE DECIMAL ATÉ A CONDIÇÃO DIZER QUE NÃO HÁ NADA NESSA PARTE
    MOVWF   TEMPERATURE_I		;SIMPLESMENTE ATUALIZA O VALOR DO TEMPERATURE PARA OPERAR NELE NOVAMENTE E NÃO ALTERAR AS OPERAÇÕES
    GOTO    LOOP_1

RESTO_TEMPERATURE
    MOVFW  TEMPERATURE_I		;COMO NA ULTIMA OPERAÇÃO O VALOR ESTA NA TEMPERATURE, ENTÃO O RESTO VAI SER O MESMO VALOR
    MOVWF  TEMPERATURE_UNI		;JOGA TAL VALOR UNIDADE	

;LOOP PARA HUMIDADE
LOOP_2	   	
    MOVLW   .10				;CARREGA O VALOR DEZ AO WORK, PARA SUBTRAIR DO FILE EM QUESTÃO
    SUBWF   HUMIDITY_I, W		;F - W, SUBTRAI DE 10 EM DEZ
    BTFSS   STATUS,C			;SE O CARRY FOR A 1, ENTÃO EU INCREMETO A PARTE DA DEZENA, CASO SEJA 0, ENTÃO NÃO HÁ MAIS NADA NA DEZENA E SALVO O RESTO NA UNIDADE
    GOTO    RESTO_HUMIDITY		;PULA PARA PARTE ONDE SALVA O RESTO
    INCF    HUMIDITY_DEZ		;INCREMENTA A PARTE DECIMAL ATÉ A CONDIÇÃO DIZER QUE NÃO HÁ NADA NESSA PARTE
    MOVWF   HUMIDITY_I			;SIMPLESMENTE ATUALIZA O VALOR DO TEMPERATURE PARA OPERAR NELE NOVAMENTE E NÃO ALTERAR AS OPERAÇÕES
    GOTO    LOOP_2

RESTO_HUMIDITY
    MOVFW   HUMIDITY_I			;COMO NA ULTIMA OPERAÇÃO O VALOR ESTA NA TEMPERATURE, ENTÃO O RESTO VAI SER O MESMO VALOR
    MOVWF   HUMIDITY_UNI		;JOGA TAL VALOR UNIDADE   
    
    RETURN
    
;READ_SENSOR LER OS DADOS ENVIADOS PELO SENSOR
READ_SENSOR
    BANK1
    BSF	    TRISA,0			;CONFIGURA O PORTA,RA0 (TRISA,0) COMO ENTRADA E ENTÃO RECEBER O SINAL DO SENSOR

    CALL    WAIT_160US

    BSF	    INDEX_REG, 0		;CONFIGURA O INDEX_REG PARA O PRIMEIRO REGISTRADOR A SER PREENCHIDO	
LOOP_40BITS				;LOOP PARA OS 40BITS
    BTFSC   INDEX_REG, 5		;TESTA SE JÁ LEU TODOS OS REGISTRADORES (SERÃO 5)
    GOTO    END_LOOP			;CASO CHEGUE AO FIM, SÓ PULA PARA O FIM DA FUNÇÃO
    CALL    WAIT_50US			;CASO AINDA TENHA VALOR A SER RECEBIDO, ESPERA OS 50US QUE O DTH ENVIA 0
    
    BANK0
    MOVLW   B'00000100'		
    MOVWF   T2CON			;COLOCA O TMR2 EM PSA DE 1:1
    BCF	    PIR1, 1			;LIMPA POR SEGURNÇA A FLAG DE ESTOURO DO TMR2
    MOVLW   .0			
    MOVWF   TMR2			;APÓS ISSO, CONFIGURA O TMR2 PARA ZERO E CONTAR A QUANTIDADE DE TEMPO QUE DTH ENVIA 1

RECEIVING				;O LOOP FICA ENQUANTO O DTH ENVIA 1 NA PORTA,RA0. AO FIM TEMOS O CORRESPONDENTE AO TEMPO
    BTFSC   PORTA, RA0
    GOTO    RECEIVING

    MOVFW   TMR2
    MOVWF   TEMP_TMR2			;SIMPLESMENTE SALVA O VALOR DO TMR2 EM UM REGISTRADOR TEMPORÁRIO PARA PRESERVAR O VALOR ORIGINAL DELE.

    BTFSC   COUNT, 3			;SE ESSE JÁ É UM NOVO REGISTRADOR, O VALOR 8 SERÁ ARMAZENADO NO COUNT, 
    CALL    ATT_COUNT_AND_INDEX		;ENTÃO CHAMA UMA FUNÇÃO PARA REINICIAR O COUNT E TROCAR O INDEX_REG

    BTFSC   INDEX_REG, 0		;TESTE PARA VER SE É O HUMIDADE INTEGRAL
    CALL    ATT_HUMIDITY_I		;ENTRA AQUI CASO SEJA O HUMIDADE INTEGRAL E FAZ OPERAÇÕES NECESSÁRIAS
    BTFSC   INDEX_REG, 1		;TESTE PARA VER SE É O HUMIDADE DECIMAL
    CALL    ATT_HUMIDITY_D		;ENTRA AQUI CASO SEJA O HUMIDADE DECIMAL E FAZ OPERAÇÕES NECESSÁRIAS
    BTFSC   INDEX_REG, 2		;TESTE PARA VER SE É O TEMPERATURA INTEGRAL
    CALL    ATT_TEMPERATURE_I		;ENTRA AQUI CASO SEJA O TEMPERATURA INTEGRAL E FAZ OPERAÇÕES NECESSÁRIAS
    BTFSC   INDEX_REG, 3		;TESTE PARA VER SE É O TEMPERATURA DECIMAL
    CALL    ATT_TEMPERATURE_D		;ENTRA AQUI CASO SEJA O TEMPERATURA DECIMAL E FAZ OPERAÇÕES NECESSÁRIAS
    BTFSC   INDEX_REG, 4		;TESTE PARA VER SE É O CHECKSUM
    CALL    CHECKSUM			;ENTRA AQUI CASO SEJA O CHECKSUM E FAZ OPERAÇÕES NECESSÁRIAS

    GOTO    LOOP_40BITS	    

END_LOOP

    CALL    WAIT_50US

    BANK1
    BCF	    TRISA,0			;CONFIGURA O PORTA,RA0 (TRISA,0) COMO SAIDA

    BANK0
    BSF	    PORTA,RA0			;COLOCA A PORTA,RA0 EM 1 NOVAMENTE.
	
    RETURN
	
;SEND_REQUEST ENVIA A REQUISIÇÃO PARA OS DADOS DO SENSOR 
SEND_REQUEST
    BCF	    PORTA,RA0
    CALL    WAIT_18MS
    BSF	    PORTA,RA0
    CALL    WAIT_40US    		    
    RETURN
    
WRITE
    MOVWF   DISPLAY			;A PARTIR DE UM VALOR JÁ SALVO NO WORK, PEGA-O E SALVA NA VARIÁVEL DISPLAY
    ;BSF	    PORTB,RB1			;SETA O PINO RS, QUE FAZ INICIAR OS DADOS, POR GARANTIA
    RLF	    DISPLAY			;DESLOCA O VALOR PARA JOGÁ-LO PARA O CARRY
    BTFSS   STATUS,C			;TESTA SE O CARRY É ZERO OU UM
    BCF	    PORTB,RB7			;CASO SEJA ZERO, COLOCA O VALOR DE ZERO NO RB7...
    BTFSC   STATUS,C			;PROSSEGUE O TESTE
    BSF	    PORTB,RB7			;CASO SEJA 1, COLOCA O VALOR DE 1 NO RB7
    
    RLF	    DISPLAY			;DESLOCA NOVAMENTE PRA O PRÓXIMO BIT SER COMPARADO E SETADO NA  PORTA CORRETAMENTE
    BTFSS   STATUS,C			;INICIA O TESTE NOVAMENTE E CONFORME RB7, O MESMO PARA O RB6
    BCF	    PORTB,RB6
    BTFSC   STATUS,C
    BSF	    PORTB,RB6
    
    RLF	    DISPLAY			;PROCEDIMENTO DE DESLOCAMENTE O TESTE NOVAMENTE PARA O RB5
    BTFSS   STATUS,C
    BCF	    PORTB,RB5
    BTFSC   STATUS,C
    BSF	    PORTB,RB5
    
    RLF	    DISPLAY			;ÚLTIMO DESLOCAMENTE E TESTE PARA OS PRIMEIRO CONJUNTO DE 4 BITS
    BTFSS   STATUS,C
    BCF	    PORTB,RB4
    BTFSC   STATUS,C
    BSF	    PORTB,RB4
    
    BSF	    PORTB,RB0			;PULSO NO ENABLE. ESPERA...
    NOP
    NOP
    BCF	    PORTB,RB0
        
    CALL    WAIT_2MS
        
    ;OS PROCEDIMENTOS ABAIXO SÃO OS MESMO QUE O ANTERIOR, PORÉM PARA OS PRÓXIMO 4 BITS
    RLF	    DISPLAY
    BTFSS   STATUS,C
    BCF	    PORTB,RB7
    BTFSC   STATUS,C
    BSF	    PORTB,RB7
    
    RLF	    DISPLAY
    BTFSS   STATUS,C
    BCF	    PORTB,RB6
    BTFSC   STATUS,C
    BSF	    PORTB,RB6
    
    RLF	    DISPLAY
    BTFSS   STATUS,C
    BCF	    PORTB,RB5
    BTFSC   STATUS,C
    BSF	    PORTB,RB5
    
    RLF	    DISPLAY
    BTFSS   STATUS,C
    BCF	    PORTB,RB4
    BTFSC   STATUS,C
    BSF	    PORTB,RB4
    
    BSF	    PORTB,RB0
    NOP
    NOP
    BCF	    PORTB,RB0
    
    CALL    WAIT_2MS       
    
    RETURN

;SETUP_DISPLAY, INICIALIZA O DISPLAY
SETUP_DISPLAY
    CALL    WAIT_18MS

    BCF	    PORTB,RB1			;LIMPA O RS
    BCF	    PORTB,RB7			;LIMPA O DB7
    BCF	    PORTB,RB6			;LIMPA O DB6
    BSF	    PORTB,RB5			;SETA O DB5
    BSF	    PORTB,RB4			;SETA O DB4
    BSF	    PORTB,RB0			;PULSO NO ENABLE
    NOP
    NOP
    BCF	    PORTB,RB0    
    CALL    WAIT_4MS
    CALL    WAIT_2MS
    
    BCF	    PORTB,RB1			;LIMPA O RS
    BCF	    PORTB,RB7			;LIMPA O DB7
    BCF	    PORTB,RB6			;LIMPA O DB6
    BSF	    PORTB,RB5			;SETA O DB5
    BSF	    PORTB,RB4			;SETA O DB4    
    BSF	    PORTB,RB0			;PULSO NO ENABLE
    NOP
    NOP
    BCF	    PORTB,RB0    
    CALL    WAIT_1MS
    
    BCF	    PORTB,RB1			;LIMPA O RS
    BCF	    PORTB,RB7			;LIMPA O DB7
    BCF	    PORTB,RB6			;LIMPA O DB6
    BSF	    PORTB,RB5			;SETA O DB5
    BSF	    PORTB,RB4			;SETA O DB4    
    BSF	    PORTB,RB0			;PULSO NO ENABLE
    NOP
    NOP
    BCF	    PORTB,RB0    
    CALL    WAIT_1MS
    
    ;ESTABELECENDO COMUNICACAO EM 4 VIAS
    BCF	    PORTB,RB1			;LIMPA O RS
    BCF	    PORTB,RB7			;LIMPA O DB7
    BCF	    PORTB,RB6			;LIMPA O DB6
    BSF	    PORTB,RB5			;SETA O DB5	    
    BCF	    PORTB,RB4			;LIMPA O DB4    
    BSF	    PORTB,RB0			;PULSO NO ENABLE
    NOP
    NOP
    BCF	    PORTB,RB0    
    CALL    WAIT_1MS
    
    MOVLW   B'00101000'			;VAI ENVIAR ENVIAR ESSA SEQUENCIA PARA ESTABELECER AS CONDIÇÕES DE UTILIZAÇÃO (COMUN EM 4VIAS)
    CALL    WRITE    
    CALL    WAIT_1MS
    
    MOVLW   B'00000001'			;VAI ENVIAR ENVIAR ESSA SEQUENCIA PARA LIMPAR O DISPLAY E POSICIONAR O CURSOR NA PRIMEIRA LINHA E COLUNA
    CALL    WRITE    
    CALL    WAIT_2MS
    
    MOVLW   B'00001100'			;ENVIA COMANDO PARA LIGAR O DISPLAY SEM CURSOR
    CALL    WRITE    
    CALL    WAIT_1MS
    
    MOVLW   B'00000110'			;ENVIA NOVAMENTE PRA ESTABELECER UM MODO DE OPERAÇÃO (DESLOACMENTE AUTOMATICO PARA DIREITA)
    CALL    WRITE    
    CALL    WAIT_1MS
    
    ;ESCREVER!!!!!!!!
    BCF	    PORTB,RB1			;DISPLAY PARA COMANDO
    MOVLW   0X01
    CALL    WRITE			;ENVIA O COMANDO PARA LIMPAR A TELA
    
    CALL    WAIT_1MS
    
    MOVLW   0X80			
    CALL    WRITE			;POSICIONA O CURSO EM (0,0)
    BSF	    PORTB,RB1			;DIPLAY PARA DADOS
    
    MOVLW   'F'
    CALL    WRITE
    MOVLW   'E'
    CALL    WRITE
    MOVLW   'L'
    CALL    WRITE
    MOVLW   'I'
    CALL    WRITE
    MOVLW   'P'
    CALL    WRITE
    MOVLW   'E'
    CALL    WRITE  
    
    BCF	    PORTB,RB1			;DISPLAY PARA COMANDO    
    MOVLW   0XC0
    CALL    WRITE			;COLOCA O CURSO EM (0,0) LINHA 1 E COLUNA 0
    BSF	    PORTB,RB1			;DISPLAY PARA DADOS
    
    MOVLW   'T'
    CALL    WRITE
    MOVLW   'E'
    CALL    WRITE
    MOVLW   'M'
    CALL    WRITE
    MOVLW   'P'
    CALL    WRITE
    MOVLW   '='
    CALL    WRITE 
    
    BCF	    PORTB,RB1			;DISPLAY PARA COMANDO    
    MOVLW   0XC7
    CALL    WRITE			;COLOCA O CURSO EM (1,7) LINHA 1 E COLUNA 7
    BSF	    PORTB,RB1			;DISPLAY PARA DADOS
    
    MOVLW   'C'
    CALL    WRITE
    MOVLW   ' '
    CALL    WRITE
    MOVLW   'U'
    CALL    WRITE
    MOVLW   'R'
    CALL    WRITE
    MOVLW   '='
    
    BCF	    PORTB,RB1			;DISPLAY PARA COMANDO    
    MOVLW   0XCE
    CALL    WRITE			;COLOCA O CURSO EM (1,14) LINHA 1 E COLUNA 14
    BSF	    PORTB,RB1			;DISPLAY PARA DADOS
 
    MOVLW   '%'
    CALL    WRITE
    
    RETURN
    
WRITE_VALUES
    ;CONVERTENDO PARA ENVIAR DE FORMA SIMPLES ('VALUE') AO DISPLAY.
    MOVLW   .48
    ADDWF   TEMPERATURE_DEZ,F
    MOVLW   .48
    ADDWF   TEMPERATURE_UNI,F
    MOVLW   .48
    ADDWF   HUMIDITY_DEZ,F
    MOVLW   .48
    ADDWF   HUMIDITY_UNI,F
    
    BCF	    PORTB,RB1			;DISPLAY PARA COMANDO    
    MOVLW   0XC5
    CALL    WRITE			;COLOCA O CURSO EM (1,14) LINHA 1 E COLUNA 5
    BSF	    PORTB,RB1			;DISPLAY PARA DADOS
          
    MOVFW   TEMPERATURE_DEZ
    CALL    WRITE
    MOVFW   TEMPERATURE_UNI
    CALL    WRITE
    
    BCF	    PORTB,RB1			;DISPLAY PARA COMANDO    
    MOVLW   0XCC
    CALL    WRITE			;COLOCA O CURSO EM (1,14) LINHA 1 E COLUNA 12
    BSF	    PORTB,RB1			;DISPLAY PARA DADOS
    
    MOVFW   HUMIDITY_DEZ
    CALL    WRITE
    MOVFW   HUMIDITY_UNI
    CALL    WRITE    
    
    RETURN
    
;---INICIO DO PROGRAMA---
INICIO					;CONFIG DOS BANCOS DE MEMORIA
    BANK1				;SELECIONA O BANCO 1
    MOVLW	B'00000000'		
    MOVWF	TRISA			;TODAS AS ENTRADAS DO PORTA COMO SAIDAS DIGITAIS 
    MOVLW	B'00000000'
    MOVWF	TRISB			;TODAS AS ENTRADAS DO PORTB COMO SAIDAS DIGITAIS   
    CLRWDT					;TRISA E TRISB FICAM COMO ENTRADA DIGITAL POR PADRAO, CASO NAO ESPECIFICADO
    MOVLW	B'00001111'
    MOVWF	OPTION_REG		;CONFIGURAÇAO DO TMR0 COM PRESCALE 1:128, QUE INICIALMENTE SERVIRA PARA ADMINISTRAR O TEMPO DE MILISEGUNDOS
    ;MOVLW	B'00000000'
    ;MOVWF	INTCON			;DEFINE OPÇÕES DE INTERRUPÇÕES
    BANK0					;SELECIONA O BANCO 0
    MOVLW	B'00000111'		
    MOVWF	CMCON			;COMPARADORES DESABILITADOS  
    MOVLW	B'00000100'
    MOVWF       T2CON
    
    ;PIC TEM OSCILADOR DE 4MHZ, O QUE IMPLICA QUE O TEMPO POR INSTRUÇAO DE MAQUINA É DE 1MS

;---INICIALIZAÇÃO DAS VARIÁVEIS---
    BSF		PORTA,RA0
    CLRF	TEMPERATURE_I
    CLRF	TEMPERATURE_D
    CLRF	HUMIDITY_I
    CLRF	HUMIDITY_D
    CLRF	CHECKSUM
    CLRF	COUNT
    CLRF	INDEX_REG
    CLRF	TEMP_TMR2    
    CLRF        TEMP    
    CLRF	TEMPERATURE_DEZ
    CLRF	TEMPERATURE_UNI
    CLRF	HUMIDITY_DEZ
    CLRF	HUMIDITY_UNI    
    CLRF	DISPLAY
        
    
    
;---ROTINA PRINCIPAL---
MAIN
    
    BSF		PORTA,RA0
    CLRF	TEMPERATURE_I
    CLRF	TEMPERATURE_D
    CLRF	HUMIDITY_I
    CLRF	HUMIDITY_D
    CLRF	CHECKSUM
    CLRF	COUNT
    CLRF	INDEX_REG
    CLRF	TEMP_TMR2    
    CLRF        TEMP    
    CLRF	TEMPERATURE_DEZ
    CLRF	TEMPERATURE_UNI
    CLRF	HUMIDITY_DEZ
    CLRF	HUMIDITY_UNI    
    CLRF	DISPLAY
    
    CALL    SETUP_DISPLAY
    CALL    SEND_REQUEST
    CALL    READ_SENSOR
    CALL    DEZENA_UNIDADE
    CALL    WRITE_VALUES
    
    CLRWDT   
    SLEEP   
    
    NOP
    
    GOTO    MAIN
    
    
    
    END					;FIM DO PROGRAMA
   